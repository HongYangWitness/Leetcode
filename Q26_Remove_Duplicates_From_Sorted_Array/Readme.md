## Valid Parentheses

- 给定一个排序数组，你需要在 **原地** 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

  不要使用额外的数组空间，你必须在 **原地 修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

  

**示例 1:**

> 给定数组 nums = [1,1,2], 
>
> 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
>
> 你不需要考虑数组中超出新长度后面的元素。
>

**示例 2:**

> 给定 nums = [0,0,1,1,1,2,2,3,3,4],
>
> 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
>
> 你不需要考虑数组中超出新长度后面的元素。
>

说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

> // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
> int len = removeDuplicates(nums);

> // 在函数里修改输入数组对于调用者是可见的。
> // 根据你的函数返回的长度, 它会打印出数组中该**长度范围**内的所有元素。
> for (int i = 0; i < len; i++) {
>     print(nums[i]);
> }




My Solution:

注意两个条件：1.直接在原数组上修改。2.只能用o(1)的额外空间。我们只需要将前n个不重复元素换到最前面，后面数组元素怎么样并不重要。所以我们要从第二个元素开始找到不同元素值并替换上去，中间涉及两个变量：当前待替换的数组位置和目前重复的值（记录重复值如果不等则为不同元素值）。

 所以我想到遍历整个数组，记录要替换元素的位置replace_index和重复元素的值duplicate。具体来说，先将replace_index设为1，重复值duplicate设为第一个元素nums[0]，如果num[i]==duplicate，则遍历下一个，当遇见不重复值时nums[i]，将replace_index位置的元素设为当前不同值nums[i]，且replace_index+1，而duplicate设为当前不同元素nums[i]的值。直到遍历完所有元素。

此方法也叫双指针。

Good Solution

**利用栈的思想，**从最后一个开始遍历，如果nums[i]==nums[i-1]，咋把nums[i]弹出。

**注意：python中 list.pop(index)可以把指定位置的元素直接剔除（不一定非要是栈顶）。**


