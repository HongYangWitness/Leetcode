## Longest Substring Without Repeating Characters

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

你可以按任意顺序返回答案。

**示例 1：**

> **输入：**s = "abcabcbb"
> **输出：**3
> **解释**：因为无重复字符的最长子串是 "abc"，所以其长度为 3。

**示例 2：**

> **输入：**s = "bbbbb"
> **输出：**1
>
> **解释**：因为无重复字符的最长子串是 "b"，所以其长度为 1。

**示例 3：**

> **输入：**s = "pwwkew"
> **输出：**3
>
> **解释**：因为无重复字符的最长子串是 "wke"，所以其长度为 3。

My Solution:

这里我使用了双指针，分别代表当前遍历的子串的开始位置（头指针）和结束位置（尾指针）。当尾指针小于最后一位时，每次比较尾指针字符与子串中前面所有字符是否相等（这里我没有用python自带的in，而是用循环遍历来检查是否相等），如果相等证明有重复的，移动头指针，否则移动尾指针并让length加一，当窗口移动时，将length和当前最长longest_length作比较。

算法可以优化的地方1）当有重复值时，头指针不需要仅仅加1，而是直接移到和尾指针相同的字符的后一位。

2）使用自带去重的数据结构进行辅助，如哈希表（python里为字典）

Good Solution：

使用字典，记录每个字符出现的位置i，和当前子串的开始位置k，每个不重复子串长度为k-i，当有重复字符c时且c除开这一次外出现位置大于k（如ases k=0，dict[c]=1,i=3）说明这个子串里面有重复的，则将k更新为重复字符的位置i，并更新重复字符的位置为i。这样只需要一次循环即可。

注意：**使用enumerate遍历，可以得到数组的值和位置**.

**hash复杂度为o(1)**